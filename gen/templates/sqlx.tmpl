{{- /*gotype: github.com/x5iu/defc/gen.sqlxContext*/ -}}
// Code generated by defc, DO NOT EDIT

package {{ $.Package }}

import (
{{ range $index, $import := $.MergedImports }} {{ $import }}
{{ end }}
)

{{ $context := $ }}
{{ $impName := (printf "impl%s" $.Ident) }}
{{ $receiver := $impName }}

func New{{ $.Ident }}(drv string, dsn string) {{ $.Ident }} {
return &{{ $impName }}{
Core: sqlx.MustOpen(drv, dsn),
}
}

func New{{ $.Ident }}FromDB(core *sqlx.DB) {{ $.Ident }} {
return &{{ $impName }}{
Core: core,
}
}

func  New{{ $.Ident }}FromCore(core interface{
{{ if $.HasFeature "sqlx/rebind" }} Rebind(query string) string {{ end }}
Beginx() (*sqlx.Tx, error)
BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
PrepareNamed(query string) (*sqlx.NamedStmt, error)
PrepareNamedContext(ctx context.Context, query string) (*sqlx.NamedStmt, error)
Exec(query string, args ...interface{}) (sql.Result, error)
ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
Get(dest interface{}, query string, args ...interface{}) error
GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
Select(dest interface{}, query string, args ...interface{}) error
SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}) {{ $.Ident }} {
return &{{ $impName }}{
Core: core,
}
}

type {{ $impName }} struct {
withTx bool
Core interface{
{{ if $.HasFeature "sqlx/rebind" }} Rebind(query string) string {{ end }}
Beginx() (*sqlx.Tx, error)
BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
PrepareNamed(query string) (*sqlx.NamedStmt, error)
PrepareNamedContext(ctx context.Context, query string) (*sqlx.NamedStmt, error)
Exec(query string, args ...interface{}) (sql.Result, error)
ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
Get(dest interface{}, query string, args ...interface{}) error
GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
Select(dest interface{}, query string, args ...interface{}) error
SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}
}

var (
{{ range $index, $method := $.Methods }} {{ printf "sqlTmpl%s" $method.Ident }} = template.Must(template.New({{ quote $method.Ident }}).Funcs(template.FuncMap{ "bindvars": __rt.BindVars, }).Parse({{ quote (readHeader $method.Header) }}))
{{ end }}
)

{{ range $index, $method := $.Methods }}
    {{ $sortIn := $method.SortIn }}
    func (imp *{{ $receiver }}) {{ $method.Ident }}(
    {{- range $index, $ident := $sortIn -}}
        {{- $ident }} {{ getRepr (index $method.In $ident) }},
    {{- end -}}
    )
    {{- if gt (len $method.Out) 0 -}}
        (
        {{- range $index, $type := $method.Out }}
            {{- getRepr $type }},
        {{- end -}}
        )
    {{- end -}}
    {
    var (
    {{ range $index, $type := $method.Out -}}
        {{ if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }} {{ if isPointer $type }}=new({{ getRepr (indirect $type) }}){{ else }}{{ getRepr $type }}{{ end }}
        {{ end -}}
    {{ end -}}
    {{- $err := printf "err%s" $method.Ident }}
    {{- $err }} error
    )

    {{ $sqlTmpl := printf "sqlTmpl%s" $method.Ident }}

    {{ $sql := printf "sql%s" $method.Ident }}
    {{ $sql }} := __rt.GetBuffer()
    defer __rt.PutBuffer({{ $sql }})
    defer {{ $sql }}.Reset()

    if {{ $err }} = {{ $sqlTmpl }}.Execute({{ $sql }}, map[string]any{
    {{ range $index, $ident := $sortIn -}}
        {{- quote $ident }}: {{ $ident -}},
    {{ end }}
    }); {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error executing %s template: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }

    {{- $log := printf "log%s" $method.Ident }}
    {{- $ok := printf "ok%s" $method.Ident }}
    {{- $start := printf "start%s" $method.Ident }}

    {{ if isExec $method.SqlxOperation }}
        {{- $tx := printf "tx%s" $method.Ident -}}
        {{ $tx }}, {{ $err }} := imp.Core.Begin{{ if $method.HasContext }}Tx{{ end }}x({{ if $method.HasContext }}ctx, nil{{ end }})
        if {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error creating %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
        }
        if !imp.withTx{
        defer {{ $tx }}.Rollback()
        }

        {{ $offset := printf "offset%s" $method.Ident }}
        {{ $args := printf "args%s" $method.Ident -}}
        {{ if hasOption ($method.SqlxOptions) "NAMED" }}
            {{ $args }} := __rt.MergeNamedArgs(map[string]any{
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- quote $ident }}: {{ $ident -}},
                {{ end -}}
            {{ end }}
            })
        {{ else }}
            {{ $offset }} := 0
            {{ $args }} := __rt.MergeArgs(
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- $ident -}},
                {{ end -}}
            {{ end }}
            )
        {{ end }}

        {{ $splitSql := printf "splitSql%s" $method.Ident }}
        for _, {{ $splitSql }} := range strings.Split({{ $sql }}.String(), ";") {
        {{ $splitSql }} = strings.TrimSpace({{ $splitSql }})
        if {{ $splitSql }} == "" {
        continue
        }
        {{ $count := printf "count%s" $method.Ident -}}
        {{ if not (hasOption ($method.SqlxOptions) "NAMED") }}
            {{ $count }} := strings.Count({{ $splitSql }}, "?")
        {{ end }}

        {{- if $.HasFeature "sqlx/rebind" }}
            {{- /* Rebind must be executed after Count */ -}}
            {{- $splitSql }} = imp.Core.Rebind({{ $splitSql }})
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            {{ $start }} := time.Now()
        {{- end }}

        {{- $execResult := printf "v0%s" $method.Ident }}
        {{ if hasOption ($method.SqlxOptions) "NAMED" }}
            {{ $stmt := printf "stmt%s" $method.Ident }}
            {{ $stmt }}, {{ $err }} := {{ $tx }}.PrepareNamed{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }})
            if {{ $err }} != nil {
            return {{ range $index, $type := $method.Out -}}
                {{- if lt $index (sub (len $method.Out) 1) -}}
                    v{{- $index -}}{{- $method.Ident }},
                {{- end -}}
            {{- end -}} fmt.Errorf("error creating %s prepare statement: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
            }

            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $stmt }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $args }})
        {{ else }}
            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := imp.Core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $splitSql }}, {{ $args }}, time.Since({{ $start }}))
            }
        {{- end }}

        if {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote({{ quote $method.Ident }}), {{ $splitSql }}, {{ $err }})
        }

        {{ if not (hasOption ($method.SqlxOptions) "NAMED") }}
            {{ $offset }} += {{ $count }}
        {{ end -}}
        }

        if !imp.withTx{
        if {{ $err }} := {{ $tx }}.Commit(); {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error committing %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
        }
        }
    {{ end }}

    {{ if isQuery $method.SqlxOperation }}
        {{ $sqlQuery := printf "sqlQuery%s" $method.Ident -}}
        {{ $sqlQuery }} := strings.TrimSpace({{ $sql }}.String())
        {{- if $.HasFeature "sqlx/rebind" }}
            {{ $sqlQuery }} = imp.Core.Rebind({{ $sqlQuery }})
        {{ end -}}
        {{- $args := printf "args%s" $method.Ident -}}
        {{ if hasOption ($method.SqlxOptions) "NAMED" }}
            {{ $args }} := __rt.MergeNamedArgs(map[string]any{
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- quote $ident }}: {{ $ident -}},
                {{ end -}}
            {{ end }}
            })
        {{ else }}
            {{ $args }} := __rt.MergeArgs(
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- $ident -}},
                {{ end -}}
            {{ end }}
            )
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            {{ $start }} := time.Now()
        {{- end }}

        {{ if hasOption ($method.SqlxOptions) "NAMED" }}
            {{ $stmt := printf "stmt%s" $method.Ident }}
            {{ $stmt }}, {{ $err }} := imp.Core.PrepareNamed{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $sqlQuery }})
            if {{ $err }} != nil {
            return {{ range $index, $type := $method.Out -}}
                {{- if lt $index (sub (len $method.Out) 1) -}}
                    v{{- $index -}}{{- $method.Ident }},
                {{- end -}}
            {{- end -}} fmt.Errorf("error creating %s prepare statement: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
            }
            {{ $err }} = {{ $stmt }}.{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}, {{ $args }})
        {{ else }}
            {{ $err }} = imp.Core.{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}, {{ $sqlQuery }}, {{ $args }}...)
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := imp.Core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $sqlQuery }}, {{ $args }}, time.Since({{ $start }}))
            }
        {{- end }}

        if  {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote({{ quote $method.Ident }}), {{ $sqlQuery }}, {{ $err }})
        }
    {{ end }}

    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} nil
    }
{{ end }}

{{ if $.WithTx }}
    {{ $tx := printf "tx%s" $.Ident }}

    func New{{ $.Ident }}FromTx{{ if $.HasFeature "sqlx/log" }}AndLog{{ end }}(core *sqlx.Tx{{ if $.HasFeature "sqlx/log" }}, log interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) } {{ end }}) {{ $.Ident }} {
    return &{{ $impName }}{
    withTx: true,
    Core: &{{ $tx }}{
    Tx: core,
    {{ if $.HasFeature "sqlx/log" -}}
        log: log,
    {{- end }}
    },
    }
    }

    type {{ $tx }} struct {
    *sqlx.Tx
    {{ if $.HasFeature "sqlx/log" -}}
        log interface {
        Log(ctx context.Context, caller string, query string, args any, elapse time.Duration)
        }
    {{ end }}
    }

    func (tx {{ $tx }}) Beginx() (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    func (tx {{ $tx }}) BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    {{ if $.HasFeature "sqlx/log" -}}
        func (tx {{ $tx }}) Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) {
        if tx.log != nil {
        tx.log.Log(ctx, caller, query, args, elapse)
        }
        }
    {{- end }}

    {{ if $.WithTxContext }}
        func (imp *{{ $receiver }}) WithTx(ctx context.Context, f func({{ $.Ident }}) error) error {
        inner, err := imp.Core.BeginTxx(ctx, nil)
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := imp.Core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        withTx: true,
        Core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ else }}
        func (imp *{{ $receiver }}) WithTx(f func({{ $.Ident }}) error) error {
        inner, err := imp.Core.Beginx()
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := imp.Core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        withTx: true,
        Core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ end }}
{{ end }}