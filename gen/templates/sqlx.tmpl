{{- /*gotype: github.com/x5iu/defc/gen.sqlxContext*/ -}}

{{- range $index, $buildTags := $.BuildTags }}
    //{{ $buildTags }}
{{- end }}

// Code generated by defc, DO NOT EDIT.

package {{ $.Package }}

import (
{{ range $index, $import := $.MergedImports }} {{ $import }}
{{ end }}
)

{{ block "schema" $ }}{{ end }}

{{ $impName := (printf "impl%s" $.Ident) }}
{{ $receiver := $impName }}

func New{{ $.Ident }}(drv string, dsn string) {{ $.Ident }} {
return &{{ $impName }}{
__core: sqlx.MustOpen(drv, dsn),
}
}

func New{{ $.Ident }}FromDB(core *sqlx.DB) {{ $.Ident }} {
return &{{ $impName }}{
__core: core,
}
}

{{ $coreInterface := (printf "%sCoreInterface" $.Ident) }}
func New{{ $.Ident }}FromCore(core {{ $coreInterface }}) {{ $.Ident }} {
return &{{ $impName }}{
__core: core,
}
}

type {{ $impName }} struct {
__withTx bool
__core {{ $coreInterface }}
}

func (__imp *{{ $receiver }}) Close() error {
if closer, ok := __imp.__core.( interface{ Close() error } ); ok {
return closer.Close()
}
return nil
}

{{ $bindVarsFunc := (printf "__%sBindVars" $.Ident) }}
{{ $additionalFuncs := $.AdditionalFuncs }}
var (
_ = (*template.Template)(nil)

{{ range $index, $method := $.Methods }} {{ if not (hasOption ($method.SqlxOptions) "CONST") }} {{ printf "sqlTmpl%s" $method.Ident }} = template.Must(template.New({{ quote $method.Ident }}).Funcs(template.FuncMap{ "bindvars": {{ if $.HasFeature "sqlx/nort" }}{{ $bindVarsFunc }}{{ else }}__rt.BindVars{{ end }}, {{ range $key, $func := $additionalFuncs }} {{ quote $key }}: {{ $func }}, {{ end }} }).Parse({{ quote (readHeader $method.Header) }}))
{{ end }}{{ end }}
)

{{ $getBufferFunc := (printf "__%sGetBuffer" $.Ident) }}
{{ $putBufferFunc := (printf "__%sPutBuffer" $.Ident) }}
{{ $mergeArgsFunc := (printf "__%sMergeArgs" $.Ident) }}
{{ $mergeNamedArgsFunc := (printf "__%sMergeNamedArgs" $.Ident) }}
{{ $inFunc := (printf "__%sIn" $.Ident) }}
{{ $countFunc := (printf "__%sCount" $.Ident) }}
{{ $splitFunc := (printf "__%sSplit" $.Ident) }}
{{ range $index, $method := $.Methods }}
    {{ $sortIn := $method.SortIn }}
    func (__imp *{{ $receiver }}) {{ $method.Ident }}(
    {{- range $index, $ident := $sortIn -}}
        {{- $ident }} {{ getRepr (index $method.In $ident) }},
    {{- end -}}
    )
    {{- if gt (len $method.Out) 0 -}}
        (
        {{- range $index, $type := $method.Out }}
            {{- getRepr $type }},
        {{- end -}}
        )
    {{- end -}}
    {
    var (
    {{ range $index, $type := $method.Out -}}
        {{ if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }} {{ if isPointer $type }}=new({{ getRepr (indirect $type) }}){{ else }}{{ getRepr $type }}{{ end }}
        {{ end -}}
    {{ end -}}
    {{- $err := printf "err%s" $method.Ident }}
    {{- $err }} error
    )

    {{ $query := printf "query%s" $method.Ident }}
    {{ if not (hasOption ($method.SqlxOptions) "CONST") }}
        {{ $sqlTmpl := printf "sqlTmpl%s" $method.Ident }}

        {{ $sql := printf "sql%s" $method.Ident }}
        {{ if $.HasFeature "sqlx/nort" }}
            {{ $sql }} := {{ $getBufferFunc }}()
            defer {{ $putBufferFunc }}({{ $sql }})
            defer {{ $sql }}.Reset()
        {{ else }}
            {{ $sql }} := __rt.GetBuffer()
            defer __rt.PutBuffer({{ $sql }})
            defer {{ $sql }}.Reset()
        {{ end }}

        if {{ $err }} = {{ $sqlTmpl }}.Execute({{ $sql }}, map[string]any{
        {{ range $index, $ident := $sortIn -}}
            {{- quote $ident }}: {{ $ident -}},
        {{ end }}
        }); {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error executing %s template: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
        }

        {{ $query }} := {{ $sql }}.String()
    {{ else }}
        {{ $query }} := {{ quote (readHeader $method.Header) }}
    {{ end }}

    {{ $log := printf "log%s" $method.Ident }}
    {{- $ok := printf "ok%s" $method.Ident }}
    {{- $start := printf "start%s" $method.Ident }}

    {{- $tx := printf "tx%s" $method.Ident }}
    {{ $tx }}, {{ $err }} := __imp.__core.Begin{{ if $method.HasContext }}Tx{{ end }}x({{ if $method.HasContext }}ctx, nil{{ end }})
    if {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error creating %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }
    if !__imp.__withTx{
    defer {{ $tx }}.Rollback()
    }

    {{ $offset := printf "offset%s" $method.Ident -}}
    {{ $args := printf "args%s" $method.Ident -}}
    {{ if hasOption ($method.SqlxOptions) "NAMED" }}
        {{ $args }} := {{ if $.HasFeature "sqlx/nort" }}{{ $mergeNamedArgsFunc }}{{ else }}__rt.MergeNamedArgs{{ end }}(map[string]any{
        {{ range $index, $ident := $sortIn -}}
            {{ if not (isContextType $ident (index $method.In $ident)) -}}
                {{- quote $ident }}: {{ $ident -}},
            {{ end -}}
        {{ end }}
        })
    {{- else }}
        {{ $offset }} := 0
        {{- if $.HasFeature "sqlx/in" }}
            {{ $query }}, {{ $args }}, {{ $err }} := {{ if $.HasFeature "sqlx/nort" }}{{ $inFunc }}{{ else }}__rt.In{{ end }}({{ $query }}, []any{
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- $ident -}},
                {{ end -}}
            {{ end }}
            })
            if {{ $err }} != nil {
            return {{ range $index, $type := $method.Out -}}
                {{- if lt $index (sub (len $method.Out) 1) -}}
                    v{{- $index -}}{{- $method.Ident }},
                {{- end -}}
            {{- end -}} fmt.Errorf("error building %s query: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
            }
        {{- else }}
            {{ $args }} := {{ if $.HasFeature "sqlx/nort" }}{{ $mergeArgsFunc }}{{ else }}__rt.MergeArgs{{ end }}(
            {{ range $index, $ident := $sortIn -}}
                {{ if not (isContextType $ident (index $method.In $ident)) -}}
                    {{- $ident -}},
                {{ end -}}
            {{ end }}
            )
        {{ end }}
    {{ end }}

    {{ $i := printf "index%s" $method.Ident }}
    {{ $count := printf "count%s" $method.Ident }}
    {{ $splitSql := printf "splitSql%s" $method.Ident }}
    {{ $sqlSlice := printf "sqlSlice%s" $method.Ident }}
    {{ $sqlSlice }} := {{ if $.HasFeature "sqlx/nort" }}{{ $splitFunc }}{{ else }}__rt.Split{{ end }}({{ $query }}, ";")
    for {{ $i }}, {{ $splitSql }} := range {{ $sqlSlice }} {
    _ = {{ $i }}

    {{- $execResult := printf "v0%s" $method.Ident }}
    {{- $singleScan := $method.SingleScan }}
    {{ if hasOption ($method.SqlxOptions) "NAMED" -}}
        {{ $argList := printf "listArgs%s" $method.Ident }}
        var {{ $argList }} []interface{}

        {{ $splitSql }}, {{ $argList }}, {{ $err }} = sqlx.Named({{ $splitSql }}, {{ $args }})
        if {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error building %s query: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
        }

        {{ if $.HasFeature "sqlx/in" }}
            {{ $splitSql }}, {{ $argList }}, {{ $err }} = {{ if $.HasFeature "sqlx/nort" }}{{ $inFunc }}{{ else }}__rt.In{{ end }}({{ $splitSql }}, {{ $argList }})
        {{ else -}}
            {{ $splitSql }}, {{ $argList }}, {{ $err }} = sqlx.In({{ $splitSql }}, {{ $argList }}...)
        {{ end -}}
        if {{ $err }} != nil {
        return {{ range $index, $type := $method.Out -}}
            {{- if lt $index (sub (len $method.Out) 1) -}}
                v{{- $index -}}{{- $method.Ident }},
            {{- end -}}
        {{- end -}} fmt.Errorf("error building %s query: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
        }

        {{- if $.HasFeature "sqlx/rebind" }}

            {{ $splitSql }} = __imp.__core.Rebind({{ $splitSql }})
        {{ end }}

        {{ if $.HasFeature "sqlx/log" }}
            {{ $start }} := time.Now()
        {{- end -}}

        {{ if isExec $method.SqlxOperation }}
            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $argList }}...)
        {{ else if isQuery $method.SqlxOperation }}
            if {{ $i }} < len({{ $sqlSlice }})-1 {
            _, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $argList }}...)
            } else {
            {{ $err }} = {{ $tx }}.{{ if hasOption ($method.SqlxOptions) "MANY" }}Select{{ else if hasOption ($method.SqlxOptions) "ONE" }}Get{{ else }}{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if $singleScan  }}{{ $singleScan }}{{ else }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}{{ end }}, {{ $splitSql }}, {{ $argList }}...)
            }
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $splitSql }}, {{ $argList }}, time.Since({{ $start }}))
            }
        {{- end }}
    {{ else }}
        {{ $count }} := {{ if $.HasFeature "sqlx/nort" }}{{ $countFunc }}{{ else }}__rt.Count{{ end }}({{ $splitSql }}, "?")
        {{ if $.HasFeature "sqlx/rebind" -}}
            {{ $splitSql }} = __imp.__core.Rebind({{ $splitSql }})
        {{ end }}

        {{- if $.HasFeature "sqlx/log" }}
            {{ $start }} := time.Now()
        {{- end -}}

        {{ if isExec $method.SqlxOperation }}
            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
        {{ else if isQuery $method.SqlxOperation }}
            if {{ $i }} < len({{ $sqlSlice }})-1 {
            _, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
            } else {
            {{ $err }} = {{ $tx }}.{{ if hasOption ($method.SqlxOptions) "MANY" }}Select{{ else if hasOption ($method.SqlxOptions) "ONE" }}Get{{ else }}{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if $singleScan  }}{{ $singleScan }}{{ else }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}{{ end }}, {{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
            }
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}], time.Since({{ $start }}))
            }
        {{- end }}
    {{ end }}

    if {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote({{ quote $method.Ident }}), {{ $splitSql }}, {{ $err }})
    }

    {{- if not (hasOption ($method.SqlxOptions) "NAMED") }}

        {{ $offset }} += {{ $count }}
    {{ end -}}
    }

    if !__imp.__withTx{
    if {{ $err }} := {{ $tx }}.Commit(); {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error committing %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }
    }

    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} nil
    }
{{ end }}

{{ if $.WithTx }}
    {{ $tx := printf "tx%s" $.Ident }}

    func New{{ $.Ident }}FromTx{{ if $.HasFeature "sqlx/log" }}AndLog{{ end }}(core *sqlx.Tx{{ if $.HasFeature "sqlx/log" }}, log interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) } {{ end }}) {{ $.Ident }} {
    return &{{ $impName }}{
    __withTx: true,
    __core: &{{ $tx }}{
    Tx: core,
    {{ if $.HasFeature "sqlx/log" -}}
        log: log,
    {{- end }}
    },
    }
    }

    type {{ $tx }} struct {
    *sqlx.Tx
    {{ if $.HasFeature "sqlx/log" -}}
        log interface {
        Log(ctx context.Context, caller string, query string, args any, elapse time.Duration)
        }
    {{ end }}
    }

    func (tx {{ $tx }}) Beginx() (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    func (tx {{ $tx }}) BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    {{ if $.HasFeature "sqlx/log" -}}
        func (tx {{ $tx }}) Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) {
        if tx.log != nil {
        tx.log.Log(ctx, caller, query, args, elapse)
        }
        }
    {{- end }}

    {{ if $.WithTxContext }}
        func (__imp *{{ $receiver }}) WithTx(ctx context.Context, f func({{ $.Ident }}) error) error {
        inner, err := __imp.__core.BeginTxx(ctx, nil)
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        __withTx: true,
        __core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ else }}
        func (__imp *{{ $receiver }}) WithTx(f func({{ $.Ident }}) error) error {
        inner, err := __imp.__core.Beginx()
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        __withTx: true,
        __core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ end }}
{{ end }}

type {{ $coreInterface }} interface {
{{ if $.HasFeature "sqlx/rebind" }} Rebind(query string) string {{ end }}
Beginx() (*sqlx.Tx, error)
BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
Exec(query string, args ...interface{}) (sql.Result, error)
ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
Get(dest interface{}, query string, args ...interface{}) error
GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
Select(dest interface{}, query string, args ...interface{}) error
SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

{{ if $.HasFeature "sqlx/nort" }}
    {{ $bufferPool := (printf "__%sBufferPool" $.Ident) }}
    var {{ $bufferPool }} = sync.Pool{
    New: func() any {
    return new(bytes.Buffer)
    },
    }

    func {{ $getBufferFunc }}() *bytes.Buffer {
    return {{ $bufferPool }}.Get().(*bytes.Buffer)
    }

    func {{ $putBufferFunc }}(buffer *bytes.Buffer) {
    {{ $bufferPool }}.Put(buffer)
    }

    {{ $notAnArg := (printf "__%sNotAnArg" $.Ident) }}
    {{ $toArgs := (printf "__%sToArgs" $.Ident) }}
    {{ $toNamedArgs := (printf "__%sToNamedArgs" $.Ident) }}
    type (
    {{ $notAnArg }} interface {
    NotAnArg()
    }

    {{ $toArgs }} interface {
    ToArgs() []any
    }

    {{ $toNamedArgs }} interface {
    ToNamedArgs() map[string]any
    }
    )

    {{ $bytesType := (printf "__%sBytesType" $.Ident) }}
    var {{ $bytesType }} = reflect.TypeOf([]byte{})

    func {{ $mergeArgsFunc }}(args ...any) []any {
    dst := make([]any, 0, len(args))
    for _, arg := range args {
    rv := reflect.ValueOf(arg)
    if _, notAnArg := arg.({{ $notAnArg }}); notAnArg {
    continue
    } else if toArgs, ok := arg.({{ $toArgs }}); ok {
    dst = append(dst, {{ $mergeArgsFunc }}(toArgs.ToArgs()...)...)
    } else if _, ok = arg.(driver.Valuer); ok {
    dst = append(dst, arg)
    } else if (rv.Kind() == reflect.Slice && !rv.Type().AssignableTo({{ $bytesType }})) ||
    rv.Kind() == reflect.Array{
    for i := 0; i < rv.Len(); i++ {
    dst = append(dst, {{ $mergeArgsFunc }}(rv.Index(i).Interface())...)
    }
    } else {
    dst = append(dst, arg)
    }
    }
    return dst
    }

    func {{ $mergeNamedArgsFunc }}(argsMap map[string]any) map[string]any {
    namedMap := make(map[string]any, len(argsMap))
    for name, arg := range argsMap {
    rv := reflect.ValueOf(arg)
    if _, notAnArg := arg.({{ $notAnArg }}); notAnArg {
    continue
    } else if toNamedArgs, ok := arg.({{ $toNamedArgs }}); ok {
    for k, v := range toNamedArgs.ToNamedArgs() {
    namedMap[k] = v
    }
    } else if _, ok = arg.(driver.Valuer); ok {
    namedMap[name] = arg
    } else if _, ok = arg.({{ $toArgs }}); ok {
    namedMap[name] = arg
    } else if rv.Kind() == reflect.Map {
    iter := rv.MapRange()
    for iter.Next() {
    k, v := iter.Key(), iter.Value()
    if k.Kind() == reflect.String {
    namedMap[k.String()] = v.Interface()
    }
    }
    } else if rv.Kind() == reflect.Struct ||
    (rv.Kind() == reflect.Pointer && rv.Elem().Kind() == reflect.Struct) {
    rv = reflect.Indirect(rv)
    rt := rv.Type()
    for i := 0; i < rt.NumField(); i++ {
    if sf := rt.Field(i); sf.Anonymous {
    sft := sf.Type
    if sft.Kind() == reflect.Pointer {
    sft = sft.Elem()
    }
    for j := 0; j < sft.NumField(); j++ {
    if tag, exists := sft.Field(j).Tag.Lookup("db"); exists {
    for pos, char := range tag {
    if !(('0' <= char && char <= '9') || ('a' <= char && char <= 'z') || ('A' <= char && char <= 'Z') || char == '_') {
    tag = tag[:pos]
    break
    }
    }
    namedMap[tag] = rv.FieldByIndex([]int{i, j}).Interface()
    }
    }
    } else if tag, exists := sf.Tag.Lookup("db"); exists {
    for pos, char := range tag {
    if !(('0' <= char && char <= '9') || ('a' <= char && char <= 'z') || ('A' <= char && char <= 'Z') || char == '_') {
    tag = tag[:pos]
    break
    }
    }
    namedMap[tag] = rv.Field(i).Interface()
    }
    }
    } else {
    namedMap[name] = arg
    }
    }
    return namedMap
    }

    func {{ $bindVarsFunc }}(data any) string {
    var n int
    switch rv := reflect.ValueOf(data); rv.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
    n = int(rv.Int())
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
    n = int(rv.Uint())
    case reflect.Slice:
    if rv.Type().AssignableTo({{ $bytesType }}) {
    n = 1
    } else {
    n = rv.Len()
    }
    default:
    n = 1
    }

    bindVars := make([]string, n)
    for i := 0; i < n; i++ {
    bindVars[i] = "?"
    }

    return strings.Join(bindVars, ", ")
    }

    {{ $splitTokensFunc := (printf "__%sSplitTokens" $.Ident) }}
    func {{ $inFunc }}(query string, args []any) (string, []any, error) {
    tokens := {{ $splitTokensFunc }}(query)
    targetArgs := make([]any, 0, len(args))
    targetQuery := make([]string, 0, len(tokens))
    n := 0
    for _, token := range tokens {
    switch token {
    case "?":
    if n >= len(args) {
    return "", nil, errors.New("number of BindVars exceeds arguments")
    }
    nested := {{ $mergeArgsFunc }}(args[n])
    if len(nested) == 0 {
    return "", nil, errors.New("empty slice passed to 'in' query")
    }
    targetArgs = append(targetArgs, nested...)
    targetQuery = append(targetQuery, {{ $bindVarsFunc }}(len(nested)))
    n++
    default:
    targetQuery = append(targetQuery, token)
    }
    }
    if n < len(args) {
    return "", nil, errors.New("number of bindVars less than number arguments")
    }
    return strings.Join(targetQuery, " "), targetArgs, nil
    }

    func {{ $countFunc }}(sql string, ch string) (n int) {
    tokens := {{ $splitTokensFunc }}(sql)
    for _, token := range tokens {
    if token == ch {
    n++
    }
    }
    return n
    }

    func {{ $splitFunc }}(sql string, sep string) (group []string) {
    tokens := {{ $splitTokensFunc }}(sql)
    group = make([]string, 0, len(tokens))
    last := 0
    for i, token := range tokens {
    if token == sep || i+1 == len(tokens) {
    if joint := strings.Join(tokens[last:i+1], " "); len(strings.Trim(joint, sep)) > 0 {
    group = append(group, joint)
    }
    last = i + 1
    }
    }
    return group
    }

    func {{ $splitTokensFunc }}(line string) (tokens []string) {
    var (
    singleQuoted bool
    doubleQuoted bool
    arg          []byte
    )

    for i := 0; i < len(line); i++ {
    switch ch := line[i]; ch {
    case ';', '?':
    if doubleQuoted || singleQuoted {
    arg = append(arg, ch)
    } else {
    if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    }
    tokens = append(tokens, string(ch))
    arg = arg[:0]
    }
    case ' ', '\t', '\n', '\r':
    if doubleQuoted || singleQuoted {
    arg = append(arg, ch)
    } else if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    arg = arg[:0]
    }
    case '"':
    if !(i > 0 && line[i-1] == '\\' || singleQuoted) {
    doubleQuoted = !doubleQuoted
    }
    arg = append(arg, ch)
    case '\'':
    if !(i > 0 && line[i-1] == '\\' || doubleQuoted) {
    singleQuoted = !singleQuoted
    }
    arg = append(arg, ch)
    default:
    arg = append(arg, ch)
    }
    }

    if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    }

    return tokens
    }
{{ end }}