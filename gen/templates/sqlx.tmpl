{{- /*gotype: github.com/x5iu/defc/gen.sqlxContext*/ -}}

{{- range $index, $buildTags := $.BuildTags }}
    //{{ $buildTags }}
{{- end }}

// Code generated by defc, DO NOT EDIT

package {{ $.Package }}

import (
{{ range $index, $import := $.MergedImports }} {{ $import }}
{{ end }}
)

{{ block "schema" $ }}{{ end }}

{{ $impName := (printf "impl%s" $.Ident) }}
{{ $receiver := $impName }}

func New{{ $.Ident }}(drv string, dsn string) {{ $.Ident }} {
return &{{ $impName }}{
__core: sqlx.MustOpen(drv, dsn),
}
}

func New{{ $.Ident }}FromDB(core *sqlx.DB) {{ $.Ident }} {
return &{{ $impName }}{
__core: core,
}
}

{{ $coreInterface := (printf "%sCoreInterface" $.Ident) }}
func New{{ $.Ident }}FromCore(core {{ $coreInterface }}) {{ $.Ident }} {
return &{{ $impName }}{
__core: core,
}
}

type {{ $impName }} struct {
__withTx bool
__core {{ $coreInterface }}
}

func (__imp *{{ $receiver }}) Close() error {
if closer, ok := __imp.__core.( interface{ Close() error } ); ok {
return closer.Close()
}
return nil
}

{{ $bindVarsFunc := (printf "__%sBindVarsFunc" $.Ident) }}
{{ $additionalFuncs := $.AdditionalFuncs }}
var (
{{ range $index, $method := $.Methods }} {{ printf "sqlTmpl%s" $method.Ident }} = template.Must(template.New({{ quote $method.Ident }}).Funcs(template.FuncMap{ "bindvars": {{ if $.HasFeature "sqlx/nort" }}{{ $bindVarsFunc }}{{ else }}__rt.BindVars{{ end }}, {{ range $key, $func := $additionalFuncs }} {{ quote $key }}: {{ $func }}, {{ end }} }).Parse({{ quote (readHeader $method.Header) }}))
{{ end }}
)

{{ $getBufferFunc := (printf "__%sGetBuffer" $.Ident) }}
{{ $putBufferFunc := (printf "__%sPutBuffer" $.Ident) }}
{{ $mergeArgsFunc := (printf "__%sMergeArgs" $.Ident) }}
{{ $mergeNamedArgsFunc := (printf "__%sMergeNamedArgs" $.Ident) }}
{{ $countFunc := (printf "__%sCount" $.Ident) }}
{{ $splitFunc := (printf "__%sSplit" $.Ident) }}
{{ range $index, $method := $.Methods }}
    {{ $sortIn := $method.SortIn }}
    func (__imp *{{ $receiver }}) {{ $method.Ident }}(
    {{- range $index, $ident := $sortIn -}}
        {{- $ident }} {{ getRepr (index $method.In $ident) }},
    {{- end -}}
    )
    {{- if gt (len $method.Out) 0 -}}
        (
        {{- range $index, $type := $method.Out }}
            {{- getRepr $type }},
        {{- end -}}
        )
    {{- end -}}
    {
    var (
    {{ range $index, $type := $method.Out -}}
        {{ if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }} {{ if isPointer $type }}=new({{ getRepr (indirect $type) }}){{ else }}{{ getRepr $type }}{{ end }}
        {{ end -}}
    {{ end -}}
    {{- $err := printf "err%s" $method.Ident }}
    {{- $err }} error
    )

    {{ $sqlTmpl := printf "sqlTmpl%s" $method.Ident }}

    {{ $sql := printf "sql%s" $method.Ident }}
    {{ if $.HasFeature "sqlx/nort" }}
        {{ $sql }} := {{ $getBufferFunc }}()
        defer {{ $putBufferFunc }}({{ $sql }})
        defer {{ $sql }}.Reset()
    {{ else }}
        {{ $sql }} := __rt.GetBuffer()
        defer __rt.PutBuffer({{ $sql }})
        defer {{ $sql }}.Reset()
    {{ end }}

    if {{ $err }} = {{ $sqlTmpl }}.Execute({{ $sql }}, map[string]any{
    {{ range $index, $ident := $sortIn -}}
        {{- quote $ident }}: {{ $ident -}},
    {{ end }}
    }); {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error executing %s template: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }

    {{- $log := printf "log%s" $method.Ident }}
    {{- $ok := printf "ok%s" $method.Ident }}
    {{- $start := printf "start%s" $method.Ident }}

    {{- $tx := printf "tx%s" $method.Ident }}
    {{ $tx }}, {{ $err }} := __imp.__core.Begin{{ if $method.HasContext }}Tx{{ end }}x({{ if $method.HasContext }}ctx, nil{{ end }})
    if {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error creating %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }
    if !__imp.__withTx{
    defer {{ $tx }}.Rollback()
    }

    {{ $offset := printf "offset%s" $method.Ident }}
    {{ $args := printf "args%s" $method.Ident -}}
    {{ if hasOption ($method.SqlxOptions) "NAMED" }}
        {{ $args }} := {{ if $.HasFeature "sqlx/nort" }}{{ $mergeNamedArgsFunc }}{{ else }}__rt.MergeNamedArgs{{ end }}(map[string]any{
        {{ range $index, $ident := $sortIn -}}
            {{ if not (isContextType $ident (index $method.In $ident)) -}}
                {{- quote $ident }}: {{ $ident -}},
            {{ end -}}
        {{ end }}
        })
    {{ else }}
        {{ $offset }} := 0
        {{ $args }} := {{ if $.HasFeature "sqlx/nort" }}{{ $mergeArgsFunc }}{{ else }}__rt.MergeArgs{{ end }}(
        {{ range $index, $ident := $sortIn -}}
            {{ if not (isContextType $ident (index $method.In $ident)) -}}
                {{- $ident -}},
            {{ end -}}
        {{ end }}
        )
    {{ end }}

    {{ $i := printf "index%s" $method.Ident }}
    {{ $count := printf "count%s" $method.Ident }}
    {{ $splitSql := printf "splitSql%s" $method.Ident }}
    {{ $sqlSlice := printf "sqlSlice%s" $method.Ident }}
    {{ $sqlSlice }} := {{ if $.HasFeature "sqlx/nort" }}{{ $splitFunc }}{{ else }}__rt.Split{{ end }}({{ $sql }}.String(), ";")
    for {{ $i }}, {{ $splitSql }} := range {{ $sqlSlice }} {
    _ = {{ $i }}

    {{ if not (hasOption ($method.SqlxOptions) "NAMED") -}}
        {{ $count }} := {{ if $.HasFeature "sqlx/nort" }}{{ $countFunc }}{{ else }}__rt.Count{{ end }}({{ $splitSql }}, "?")
    {{- end }}

    {{- $execResult := printf "v0%s" $method.Ident }}
    {{ if hasOption ($method.SqlxOptions) "NAMED" -}}
        {{ $argList := printf "listArgs%s" $method.Ident }}
        var {{ $argList }} []interface{}
        {{ $splitSql }}, {{ $argList }}, {{ $err }} = sqlx.Named({{ $splitSql }}, {{ $args }})
        {{ $splitSql }}, {{ $argList }}, {{ $err }} = sqlx.In({{ $splitSql }}, {{ $argList }}...)

        {{- if $.HasFeature "sqlx/rebind" }}
            {{ $splitSql }} = __imp.__core.Rebind({{ $splitSql }})
        {{ end }}

        {{ if $.HasFeature "sqlx/log" }}
            {{ $start }} := time.Now()
        {{- end -}}

        {{ if isExec $method.SqlxOperation }}
            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $argList }}...)
        {{ else if isQuery $method.SqlxOperation }}
            if {{ $i }} < len({{ $sqlSlice }})-1 {
            _, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $argList }}...)
            } else {
            {{ $err }} = {{ $tx }}.{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}, {{ $splitSql }}, {{ $argList }}...)
            }
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $splitSql }}, {{ $argList }}, time.Since({{ $start }}))
            }
        {{- end }}
    {{ else }}
        {{- if $.HasFeature "sqlx/rebind" -}}
            {{ $splitSql }} = __imp.__core.Rebind({{ $splitSql }})
        {{ end }}

        {{- if $.HasFeature "sqlx/log" }}
            {{ $start }} := time.Now()
        {{- end -}}

        {{ if isExec $method.SqlxOperation }}
            {{ if gt (len $method.Out) 1 }}{{ $execResult }}{{ else }}_{{ end }}, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
        {{ else if isQuery $method.SqlxOperation }}
            if {{ $i }} < len({{ $sqlSlice }})-1 {
            _, {{ $err }} = {{ $tx }}.Exec{{ if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
            } else {
            {{ $err }} = {{ $tx }}.{{ if isSlice (index $method.Out 0) }}Select{{ else }}Get{{ end }}{{if $method.HasContext }}Context{{ end }}({{ if $method.HasContext }}ctx, {{ end }}{{ if not (isPointer (index $method.Out 0)) }}&{{ end }}v0{{ $method.Ident }}, {{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}]...)
            }
        {{ end }}

        {{ if $.HasFeature "sqlx/log" -}}
            if {{ $log }}, {{ $ok }} := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); {{ $ok }} {
            {{ $log }}.Log({{ if $method.HasContext }}ctx{{ else }}context.Background(){{ end }}, {{ quote $method.Ident }}, {{ $splitSql }}, {{ $args }}[{{ $offset }}:{{ $offset }}+{{ $count }}], time.Since({{ $start }}))
            }
        {{- end }}
    {{ end }}

    if {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote({{ quote $method.Ident }}), {{ $splitSql }}, {{ $err }})
    }

    {{- if not (hasOption ($method.SqlxOptions) "NAMED") }}

        {{ $offset }} += {{ $count }}
    {{ end -}}
    }

    if !__imp.__withTx{
    if {{ $err }} := {{ $tx }}.Commit(); {{ $err }} != nil {
    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} fmt.Errorf("error committing %s transaction: %w", strconv.Quote({{ quote $method.Ident }}), {{ $err }})
    }
    }

    return {{ range $index, $type := $method.Out -}}
        {{- if lt $index (sub (len $method.Out) 1) -}}
            v{{- $index -}}{{- $method.Ident }},
        {{- end -}}
    {{- end -}} nil
    }
{{ end }}

{{ if $.WithTx }}
    {{ $tx := printf "tx%s" $.Ident }}

    func New{{ $.Ident }}FromTx{{ if $.HasFeature "sqlx/log" }}AndLog{{ end }}(core *sqlx.Tx{{ if $.HasFeature "sqlx/log" }}, log interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) } {{ end }}) {{ $.Ident }} {
    return &{{ $impName }}{
    __withTx: true,
    __core: &{{ $tx }}{
    Tx: core,
    {{ if $.HasFeature "sqlx/log" -}}
        log: log,
    {{- end }}
    },
    }
    }

    type {{ $tx }} struct {
    *sqlx.Tx
    {{ if $.HasFeature "sqlx/log" -}}
        log interface {
        Log(ctx context.Context, caller string, query string, args any, elapse time.Duration)
        }
    {{ end }}
    }

    func (tx {{ $tx }}) Beginx() (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    func (tx {{ $tx }}) BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error) {
    return tx.Tx, nil
    }

    {{ if $.HasFeature "sqlx/log" -}}
        func (tx {{ $tx }}) Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) {
        if tx.log != nil {
        tx.log.Log(ctx, caller, query, args, elapse)
        }
        }
    {{- end }}

    {{ if $.WithTxContext }}
        func (__imp *{{ $receiver }}) WithTx(ctx context.Context, f func({{ $.Ident }}) error) error {
        inner, err := __imp.__core.BeginTxx(ctx, nil)
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        __withTx: true,
        __core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ else }}
        func (__imp *{{ $receiver }}) WithTx(f func({{ $.Ident }}) error) error {
        inner, err := __imp.__core.Beginx()
        if err != nil {
        return fmt.Errorf("error creating transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        defer inner.Rollback()

        core := &{{ $tx }}{
        Tx: inner,
        }

        {{ if $.HasFeature "sqlx/log" -}}
            if log, ok := __imp.__core.(interface{ Log(ctx context.Context, caller string, query string, args any, elapse time.Duration) }); ok {
            core.log = log
            }
        {{ end }}

        tx := &{{ $impName }}{
        __withTx: true,
        __core: core,
        }

        if err = f(tx); err != nil {
        return err
        }

        if err = inner.Commit(); err != nil {
        return fmt.Errorf("error committing transaction in %s: %w", strconv.Quote("WithTx"), err)
        }

        return nil
        }
    {{ end }}
{{ end }}

type {{ $coreInterface }} interface {
{{ if $.HasFeature "sqlx/rebind" }} Rebind(query string) string {{ end }}
Beginx() (*sqlx.Tx, error)
BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
Exec(query string, args ...interface{}) (sql.Result, error)
ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
Get(dest interface{}, query string, args ...interface{}) error
GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
Select(dest interface{}, query string, args ...interface{}) error
SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

{{ if $.HasFeature "sqlx/nort" }}
    {{ $bufferPool := (printf "__%sBufferPool" $.Ident) }}
    var {{ $bufferPool }} = sync.Pool{
    New: func() any {
    return new(bytes.Buffer)
    },
    }

    func {{ $getBufferFunc }}() *bytes.Buffer {
    return {{ $bufferPool }}.Get().(*bytes.Buffer)
    }

    func {{ $putBufferFunc }}(buffer *bytes.Buffer) {
    {{ $bufferPool }}.Put(buffer)
    }

    {{ $notAnArg := (printf "__%sNotAnArg" $.Ident) }}
    {{ $toArgs := (printf "__%sToArgs" $.Ident) }}
    {{ $toNamedArgs := (printf "__%sToNamedArgs" $.Ident) }}
    type (
    {{ $notAnArg }} interface {
    NotAnArg()
    }

    {{ $toArgs }} interface {
    ToArgs() []any
    }

    {{ $toNamedArgs }} interface {
    ToNamedArgs() map[string]any
    }
    )

    {{ $bytesType := (printf "__%sBytesType" $.Ident) }}
    var {{ $bytesType }} = reflect.TypeOf([]byte{})

    func {{ $mergeArgsFunc }}(args ...any) []any {
    dst := make([]any, 0, len(args))
    for _, arg := range args {
    rv := reflect.ValueOf(arg)
    if _, notAnArg := arg.({{ $notAnArg }}); notAnArg {
    continue
    } else if toArgs, ok := arg.({{ $toArgs }}); ok {
    for _, v := range toArgs.ToArgs() {
    dst = append(dst, v)
    }
    } else if _, ok = arg.(driver.Valuer); ok {
    dst = append(dst, arg)
    } else if (rv.Kind() == reflect.Slice && rv.Type() != {{ $bytesType }}) ||
    rv.Kind() == reflect.Array{
    for i := 0; i < rv.Len(); i++ {
    dst = append(dst, rv.Index(i).Interface())
    }
    } else {
    dst = append(dst, arg)
    }
    }
    return dst
    }

    func {{ $mergeNamedArgsFunc }}(argsMap map[string]any) map[string]any {
    namedMap := make(map[string]any, len(argsMap))
    for name, arg := range argsMap {
    rv := reflect.ValueOf(arg)
    if _, notAnArg := arg.({{ $notAnArg }}); notAnArg {
    continue
    } else if toNamedArgs, ok := arg.({{ $toNamedArgs }}); ok {
    for k, v := range toNamedArgs.ToNamedArgs() {
    namedMap[k] = v
    }
    } else if _, ok = arg.(driver.Valuer); ok {
    namedMap[name] = arg
    } else if rv.Kind() == reflect.Map {
    iter := rv.MapRange()
    for iter.Next() {
    k, v := iter.Key(), iter.Value()
    if k.Kind() == reflect.String {
    namedMap[k.String()] = v.Interface()
    }
    }
    } else if rv.Kind() == reflect.Struct ||
    (rv.Kind() == reflect.Pointer && rv.Elem().Kind() == reflect.Struct) {
    rt := reflect.Indirect(rv).Type()
    for i := 0; i < rt.NumField(); i++ {
    if tag, ok := rt.Field(i).Tag.Lookup("db"); ok {
    namedMap[tag] = rv.Field(i).Interface()
    }
    }
    } else {
    namedMap[name] = arg
    }
    }
    return namedMap
    }

    func {{ $bindVarsFunc }}(data any) string {
    var n int
    switch rv := reflect.ValueOf(data); rv.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
    n = int(rv.Int())
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
    n = int(rv.Uint())
    case reflect.Slice:
    if rv.Type() == {{ $bytesType }} {
    n = 1
    } else {
    n = rv.Len()
    }
    default:
    n = 1
    }

    bindVars := make([]string, n)
    for i := 0; i < n; i++ {
    bindVars[i] = "?"
    }

    return strings.Join(bindVars, ", ")
    }

    {{ $splitTokensFunc := (printf "__%sSplitTokens" $.Ident) }}
    func {{ $countFunc }}(sql string, ch string) (n int) {
    tokens := {{ $splitTokensFunc }}(sql)
    for _, token := range tokens {
    if token == ch {
    n++
    }
    }
    return n
    }

    func {{ $splitFunc }}(sql string, sep string) (group []string) {
    tokens := {{ $splitTokensFunc }}(sql)
    group = make([]string, 0, len(tokens))
    last := 0
    for i, token := range tokens {
    if token == sep {
    if joint := strings.Join(tokens[last:i+1], " "); len(strings.Trim(joint, sep)) > 0 {
    group = append(group, joint)
    }
    last = i + 1
    }
    }
    return group
    }

    func {{ $splitTokensFunc }}(line string) (tokens []string) {
    var (
    singleQuoted bool
    doubleQuoted bool
    arg          []byte
    )

    for i := 0; i < len(line); i++ {
    switch ch := line[i]; ch {
    case ';', '?':
    if doubleQuoted || singleQuoted {
    arg = append(arg, ch)
    } else {
    if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    }
    tokens = append(tokens, string(ch))
    arg = arg[:0]
    }
    case ' ', '\t', '\n', '\r':
    if doubleQuoted || singleQuoted {
    arg = append(arg, ch)
    } else if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    arg = arg[:0]
    }
    case '"':
    if !(i > 0 && line[i-1] == '\\' || singleQuoted) {
    doubleQuoted = !doubleQuoted
    }
    arg = append(arg, ch)
    case '\'':
    if !(i > 0 && line[i-1] == '\\' || doubleQuoted) {
    singleQuoted = !singleQuoted
    }
    arg = append(arg, ch)
    default:
    arg = append(arg, ch)
    }
    }

    if len(arg) > 0 {
    tokens = append(tokens, string(arg))
    }

    return tokens
    }
{{ end }}