{{- /*gotype: github.com/x5iu/defc/gen.rpcContext*/ -}}

{{- range $index, $buildTags := $.BuildTags }}
    //{{ $buildTags }}
{{- end }}

// Code generated by defc, DO NOT EDIT.

package {{ $.Package }}

{{ $runtime := "defcruntime" }}
import (
    "net/rpc"

    {{ $runtime }} "github.com/x5iu/defc/runtime"
)

{{ $impName := (printf "impl%s" $.Ident) }}
{{ $newFunc := (printf "new%sType" $.Ident) }}

{{ $rpcClient := "rpcClient" }}
func New{{- $.Ident }}(rpcClient *rpc.Client) {{ $.Ident }} {
    return &{{ $impName }}{  {{ $rpcClient }}: rpcClient  }
}

type {{ $impName }} struct{
    {{ $rpcClient }} *rpc.Client
}

{{ $receiver := "impl" }}
{{ range $index, $method := $.Methods }}
    {{ $err := printf "%sErr" $method.Ident }}
    {{ $sortIn := $method.SortIn }}
    func ({{ $receiver }} *{{ $impName }}) {{ $method.Ident }}(
    {{- range $index, $ident := $sortIn -}}
        {{- $ident }} {{ getRepr (index $method.In $ident) }},
    {{- end -}}
    )
    {{- if gt (len $method.Out) 0 -}}
        (
        {{- range $index, $type := $method.Out }}
            {{- getRepr $type }},
        {{- end -}}
        )
    {{- end -}}
    {
        {{ $isReplyPointerType := false -}}
        {{ $rpcReply := printf "%sRPCReply" $method.Ident -}}
        {{ $rpcReply }} := {{ range $index, $type := $method.Out -}}
            {{- if eq $index 0 -}}
                {{- if isPointer $type -}}
                    {{ $isReplyPointerType = true }}
                    new({{ getRepr (indirect $type) }})
                {{- else -}}
                    {{ if $.HasFeature "rpc/nort" }}{{ $newFunc }}{{ else }}{{ $runtime }}.New{{ end }}[{{ getRepr $type }}]()
                {{- end -}}
            {{- end -}}
        {{- end }}
        {{ $err }} := {{ $receiver }}.{{ $rpcClient }}.Call("{{ $.Ident }}.{{ $method.Ident }}", {{- range $index, $ident := $sortIn -}}
            {{- $ident }},
        {{- end -}} {{ if not $isReplyPointerType }}&{{ end }}{{ $rpcReply }})
        if {{ $err }} != nil {
            return {{ if not $isReplyPointerType }}{{ $rpcReply }}{{ else }}nil{{ end }}, {{ $err }}
        }
        return {{ $rpcReply }}, nil
    }
{{ end }}

func New{{ $.Ident }}Server(impl {{ $.Ident }}) *{{ $.Ident }}Server {
    return &{{ $.Ident }}Server{
        {{ $impName }}: impl,
    }
}

{{ $receiver := "srv" }}
type {{ $.Ident }}Server struct {
    {{ $impName }} {{ $.Ident }}
}

{{ range $index, $method := $.Methods }}
    {{ $err := printf "%sErr" $method.Ident }}
    {{ $arg := index $method.In ( index $method.SortIn 0 ) }}
    {{ $reply := index $method.Out 0 }}
    func ({{ $receiver }} *{{ $.Ident }}Server) {{ $method.Ident }}(
    arg {{ getRepr $arg }},
    reply {{ if not ( isPointer $reply ) }}*{{ end }}{{ getRepr $reply }},
    ) error {
        {{ $rpcReply := printf "%sRPCReply" $method.Ident -}}
        {{ $rpcReply }}, {{ $err }} := {{ $receiver }}.{{ $impName }}.{{ $method.Ident }}(arg)
        if {{ $err }} != nil {
            return {{ $err }}
        }
        {{ if isChan ( indirect $reply ) -}}
        if reply != nil && *reply != nil {
            close(*reply)
        }
        {{- end }}
        *reply = {{ if isPointer $reply }}*{{ end }}{{ $rpcReply }}
        return nil
    }
{{ end }}

{{ if $.HasFeature "rpc/nort" }}
    {{ $newTypeFunc := (printf "new%sReflectType" $.Ident) }}
    func {{ $newTypeFunc }}(typ reflect.Type) reflect.Value {
        switch typ.Kind() {
        case reflect.Slice:
            return reflect.MakeSlice(typ, 0, 0)
        case reflect.Map:
            return reflect.MakeMap(typ)
        case reflect.Chan:
            return reflect.MakeChan(typ, 0)
        case reflect.Func:
            return reflect.MakeFunc(typ, func(_ []reflect.Value) (results []reflect.Value) {
                results = make([]reflect.Value, typ.NumOut())
                for i := 0; i < typ.NumOut(); i++ {
                    results[i] = {{ $newTypeFunc }}(typ.Out(i))
                }
                return results
            })
        case reflect.Pointer:
            return reflect.New(typ.Elem())
        default:
            return reflect.Zero(typ)
        }
    }
    func {{ $newFunc }}[T any]() (v T) {
        val := reflect.ValueOf(&v).Elem()
        switch val.Kind() {
        case reflect.Slice, reflect.Map, reflect.Chan, reflect.Func, reflect.Pointer:
            val.Set({{ $newTypeFunc }}(val.Type()))
        }
        return v
    }
{{ end }}